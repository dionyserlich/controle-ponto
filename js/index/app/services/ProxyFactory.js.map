{"version":3,"sources":["services/ProxyFactory.js"],"names":["ProxyFactory","Error","object","params","act","Proxy","get","target","prop","receiver","includes","_validaFuncao","retorno","Reflect","apply","arguments","set","value","funcao","Function"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAMA,wB;AAEF,wCAAc;AAAA;;AACV,0BAAM,IAAIC,KAAJ,CAAU,iCAAV,CAAN;AACH;;;;2CAEaC,M,EAAQC,M,EAAQC,G,EAAK;;AAE/B,+BAAO,IAAIC,KAAJ,CAAUH,MAAV,EAAkB;AAIrBI,+BAJqB,eAIjBC,MAJiB,EAITC,IAJS,EAIHC,QAJG,EAIO;AACxB;;;;;;AAMA;AACA,oCAAIN,OAAOO,QAAP,CAAgBF,IAAhB,KAAyBR,aAAaW,aAAb,CAA2BJ,OAAOC,IAAP,CAA3B,CAA7B,EAAuE;;AAEnE;AACA,2CAAO,YAAY;AACf;AACA,4CAAII,UAAUC,QAAQC,KAAR,CAAcP,OAAOC,IAAP,CAAd,EAA4BD,MAA5B,EAAoCQ,SAApC,CAAd;AACA;AACAX,4CAAIG,MAAJ;;AAEA,+CAAOK,OAAP;AACH,qCAPD;AAQH;AACD,uCAAOC,QAAQP,GAAR,CAAYC,MAAZ,EAAoBC,IAApB,EAA0BC,QAA1B,CAAP;AACH,6BAzBoB;AA0BrBO,+BA1BqB,eA0BjBT,MA1BiB,EA0BTC,IA1BS,EA0BHS,KA1BG,EA0BIR,QA1BJ,EA0Bc;;AAE/B,oCAAIG,UAAUC,QAAQG,GAAR,CAAYT,MAAZ,EAAoBC,IAApB,EAA0BS,KAA1B,EAAiCR,QAAjC,CAAd;AACA,oCAAIN,OAAOO,QAAP,CAAgBF,IAAhB,CAAJ,EAA2B;AACvBJ,wCAAIG,MAAJ;AACH;;AAED,uCAAOK,OAAP;AAEH;AAnCoB,yBAAlB,CAAP;AAsCH;;;kDAEoBM,M,EAAQ;AACzB,+BAAO,QAAOA,MAAP,yCAAOA,MAAP,cAAyBC,QAAzB,yCAAyBA,QAAzB,EAAP;AACH;;;;;;+BAGUnB,Y","file":"services/ProxyFactory.js","sourcesContent":["class ProxyFactory {\n\n    constructor() {\n        throw new Error('Classe não pode ser instanciada');\n    }\n\n    static create(object, params, act) {\n\n        return new Proxy(object, {\n            //Faz a interceptação dos métodos adiciona e esvazia\n            //Isso é possível usando get porque antes de chamar uma função, o JS da um GET e depois um apply,\n            //Logo, conseguimos pegar o disparo do get.\n            get(target, prop, receiver) {\n                /*\n                Target: o objeto encapsulado -> Lista de Pontos (ListaPont())\n                prop: propriedade do target (esvazia, adiciona, ou qualquer outra)\n                reciever: Referencia para o Proxy \n                */\n\n                //Valida se são os metodos \n                if (params.includes(prop) && ProxyFactory._validaFuncao(target[prop])) {\n\n                    //retorna a função interceptada\n                    return function () {\n                        //reflete a função que foi chamada\n                        let retorno = Reflect.apply(target[prop], target, arguments);\n                        //Disparada meu evento de atualização da view, agora já no target(Lista de Pontos); \n                        act(target);\n\n                        return retorno;\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            },\n            set(target, prop, value, receiver) {\n\n                let retorno = Reflect.set(target, prop, value, receiver);\n                if (params.includes(prop)) {\n                    act(target);\n                }\n\n                return retorno;\n\n            }\n        });\n\n    }\n\n    static _validaFuncao(funcao) {\n        return typeof funcao == typeof (Function);\n    }\n}\n\nexport default ProxyFactory;"],"sourceRoot":"/source/"}